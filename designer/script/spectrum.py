import numpy as np
from tmm import get_E
import tmm.get_spectrum as get_spectrum
from abc import ABC, abstractmethod


class BaseSpectrum(ABC):
    # TODO: add support for polarization
    def __init__(self, incident_angle, wavelengths, spec_R, spec_T):
        self.INC_ANG = incident_angle
        self.WLS = wavelengths
        self.spec_R = spec_R
        self.spec_T = spec_T

    @abstractmethod
    def get_R(self):
        try:
            return self.spec_R
        except AttributeError:
            raise ValueError('spec R not initialized')

    @abstractmethod
    def get_T(self):
        try:
            return self.spec_T
        except AttributeError:
            raise ValueError('spec R not initialized')


class Spectrum(BaseSpectrum):
    """
    An object containing the spectrum

    Attributes:
        INC_ANG (float):
        WLS (NDArray):
        spec_R (NDArray):
            The REFLECTANCE spectrum.
        spec_T (NDArray):
            The transmittance spectrum. Subject to future changes
    """

    def __init__(self, incident_angle, wavelengths, spec_R, spec_T=None):
        if spec_T is None:
            spec_T = 1 - spec_R

        super().__init__(incident_angle, wavelengths, spec_R, spec_T)

    def get_R(self):
        return super().get_R()

    def get_T(self):
        return super().get_T()


class SpectrumSimple(BaseSpectrum):
    """
    A spectrum that is generated by a Film.

    Attributes:    
    INC_ANG (float):
    WLS (NDArray):
    spec (NDArray):
        The REFLECTANCE spectrum. In FilmSimple instances, no absorption so 
        only R is considered
    updated:
        When an instance of Film has a SpectrumSimple, update denotes whether 
        this spectrum is updated in regard to the current film structure.
    """

    def __init__(self, incident_angle, wavelengths, film):
        self.INC_ANG = incident_angle
        self.WLS = wavelengths
        self.n_sub = film.calculate_n_sub(self.WLS)
        self.n_inc = film.calculate_n_inc(self.WLS)
        # spec: R, T
        self.spec = np.empty(self.WLS.shape[0] * 2)
        # spec_E: E+s, E+p// E-s, E-p
        self.spec_E = np.empty((self.WLS.shape[0] * 2, 2), dtype='complex128')
        # spec_r: rs // rp
        self.spec_r = np.empty((self.WLS.shape[0], 2), dtype='complex128')
        self.film = film
        self.updated = False

    def calculate(self, spec_func=get_spectrum.get_spectrum_free, **kwargs):
        # only R spectrum
        spec_func(
            self.spec,
            self.WLS,
            self.film.get_d(),
            self.film.calculate_n_array(self.WLS),
            self.n_sub,
            self.n_inc,
            self.INC_ANG, 
            **kwargs
        )
        self.spec_R = self.spec[:self.WLS.shape[0]]
        self.spec_T = self.spec[self.WLS.shape[0]:]

    def calculate_E(self, spec_func=get_E.get_E_free, **kwargs):
        spec_func(
            self.spec_E,
            self.WLS,
            self.film.get_d(),
            self.film.calculate_n_array(self.WLS),
            self.n_sub,
            self.n_inc,
            self.INC_ANG, 
            **kwargs
        )
        # rs
        self.spec_r[:, 0] = self.spec_E[:self.WLS.shape[0], 1] \
              / self.spec_E[:self.WLS.shape[0], 0]
        # rp
        self.spec_r[:, 1] = self.spec_E[self.WLS.shape[0]:, 1] \
              / self.spec_E[self.WLS.shape[0]:, 0]
        
    def outdate(self):
        self.updated = False
        self.updated_E = False
        
    def get_R(self, **kwargs):
        self.calculate(**kwargs)
        return self.spec_R

    def get_T(self, **kwargs):
        self.calculate(**kwargs)
        return self.spec_T

    def get_r(self, **kwargs):
        self.calculate_E(**kwargs)
        return self.spec_r
    
    def get_tanPsi(self):
        r = self.get_r()
        rs = r[:, 0]
        rp = r[:, 1]
        return np.abs(rp / rs)

    def get_delta(self):
        r = self.get_r()
        rs = r[:, 0]
        rp = r[:, 1]
        return np.angle(rp / rs)
