import numpy as np
from film import BaseFilm
from spectrum import BaseSpectrum
from typing import Sequence


def calculate_RMS(film1: BaseFilm, film2: BaseFilm):
    ''' calculates the RMS loss of the spectrum generated by two given films 
    '''
    R_1 = np.array([])
    R_2 = np.array([])
    T_1 = np.array([])
    T_2 = np.array([])

    for this_spec_film1 in film1.get_all_spec_list():
        # target spectrum params
        inc_ang, wls = this_spec_film1.INC_ANG, this_spec_film1.WLS
        this_spec_film2 = film2.get_spec(inc_ang, wls)
        # if spec updated, no need to calculate again
        if not this_spec_film1.is_updated():
            this_spec_film1.calculate()
        if not this_spec_film2.is_updated():
            this_spec_film2.calculate()
        # R and T spec are counted
        R_1 = np.append(R_1, this_spec_film1.get_R())
        R_2 = np.append(R_2, this_spec_film2.get_R())

        T_1 = np.append(T_1, this_spec_film1.get_T())
        T_2 = np.append(T_2, this_spec_film2.get_T())
    # merit: RMS
    f = np.append(R_1 - R_2, T_1 - T_2)
    return rms(f)


def calculate_RMS_f_spec(film: BaseFilm, specs: Sequence[BaseSpectrum]):
    '''
        calculates RMS loss of the spectrum generated by one given films wrt a 
        given spectrum
    '''
    R_1 = np.array([])
    R_2 = np.array([])
    T_1 = np.array([])
    T_2 = np.array([])

    assert type(
        specs) is list, 'Target spectrums should be python list even if only one spectrum is target!'

    for spec in specs:
        # target spectrum params
        inc_ang, wls = spec.INC_ANG, spec.WLS
        this_spec_film = film.get_spec(inc_ang, wls)
        # if spec updated, no need to calculate again
        if not this_spec_film.is_updated():
            this_spec_film.calculate()
        # R and T spec are counted
        R_1 = np.append(R_1, this_spec_film.get_R())
        R_2 = np.append(R_2, spec.get_R())

        T_1 = np.append(T_1, this_spec_film.get_T())
        T_2 = np.append(T_2, spec.get_T())
    # merit: RMS
    f = np.append(R_1 - R_2, T_1 - T_2)
    return rms(f)


def rms(f):
    return np.sqrt(np.sum(np.square(f)) / f.shape[0])
